#!/usr/bin/env python3

"""
Build a correct BEASTling model.

This auxiliary script uses both the original and the patched version
of BEASTling, combining the results by using temporary files.
While both versions of BEASTling can be used as Python libraries,
we just call the programs to make it easier to understand and tweak with.
"""

# Import Python standard libraries
from pathlib import Path
import glob
import logging
import subprocess
import re
import string

# Import 3rd party
from unidecode import unidecode

# Note: we don't import from `common` due to the CLLD dependencies there
def slug(label: str, level: str) -> str:
    """
    Return a slugged version of a label.
    @param label: The text to be slugged. Note that, as this operates on
        a single string, there is no guarantee of non-collision.
    @param level: Define the level of slugging to be applied. Currently,
        accepted levels are "none", "simple", and "full".
    @return: The slugged version of the label.
    """

    if level not in ["none", "simple", "full"]:
        raise ValueError(f"Unknown level of slugging `{level}`.")

    logging.debug("Slugging label `%s` with level `%s`.", label, level)

    # This implementation of the different levels of slugging seems a
    # bit cumbersome at first, but makes it easy for us to explore alternatives
    if level in ["simple", "full"]:
        label = unidecode(label)
    if level in ["full"]:
        label = label.lower()
    if level in ["simple"]:
        label = "".join(
            [
                char
                for char in label
                if char in string.ascii_letters + string.digits + "-_"
            ]
        )
    if level in ["full"]:
        label = "".join([char for char in label if char in string.ascii_letters])
    if level in ["simple", "full"]:
        label = re.sub(r"\s+", "_", label.strip())

    logging.debug("Label slugged to `%s`.", label)

    return label


def main():
    """
    Script entry point.
    """
    # Grab the BAYES_PATH for the latestes release and a list of all configurations
    RELEASES_PATH = Path(__file__).parent.parent / "releases" / "*"
    release = sorted(glob.glob(str(RELEASES_PATH)))[-1]
    BAYES_PATH = Path(release) / "bayesian"

    confs = [Path(conf) for conf in glob.glob(str(BAYES_PATH / "*.conf"))]

    # Generate a first XML model with the patched version of beastling,
    # in order to obtain the correct matrix reading and save it for future
    # replacement
    for conf in confs:
        # Build files
        logging.info(f"Building BEASTling models for `{conf.name}`...")
        patch_file = f"{conf.stem}.patch.xml"
        vanilla_file = f"{conf.stem}.vanilla.xml"
        model_file = f"{slug(conf.stem, level='full')}.xml"

        subprocess.run(["beastling_patch", conf.name, "-o", patch_file], cwd=BAYES_PATH)
        subprocess.run(["beastling", conf.name, "-o", vanilla_file], cwd=BAYES_PATH)

        # Read data with question marks and delete file
        patch_file_path = BAYES_PATH / patch_file
        with open(patch_file_path) as handler:
            in_data = False
            data = []
            for line in handler.readlines():
                if '  <data id="data_' in line:
                    in_data = True
                elif "</data>" in line:
                    in_data = False
                elif in_data:
                    data.append(line)
        patch_file_path.unlink()

        # Read the vanilla file, replace contents, and delete the vanilla file
        vanilla_file_path = BAYES_PATH / vanilla_file
        with open(vanilla_file_path) as handler:
            in_data = False
            in_comment = False  # our files are not reproducible with beastling
            correct_lines = []
            for line in handler.readlines():
                if '  <data id="data_' in line:
                    correct_lines.append(line)
                    correct_lines += data
                    in_data = True
                    continue
                elif "</data>" in line:
                    correct_lines.append(line)
                    in_data = False
                    continue

                if "  <!--Generated by BEASTling" in line:
                    in_comment = True
                if in_comment and "-->" in line:
                    in_comment = False
                    continue

                if not in_data and not in_comment:
                    correct_lines.append(line)

        vanilla_file_path.unlink()

        # Output the correct file
        with open(BAYES_PATH / model_file, "w") as handler:
            handler.write("".join(correct_lines))


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    main()
